{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    unaryMinus,\n    lup\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});","map":{"version":3,"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","unaryMinus","lup","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","decomp","U","_i","evenCycles","i","visited","j","cycleLen","p"],"sources":["C:/Users/lauta/node_modules/mathjs/lib/esm/function/matrix/det.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    unaryMinus,\n    lup\n  } = _ref;\n\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}