{"ast":null,"code":"import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","name","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","isArray","every","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","range","i","needsEnd","childArgNames","Object","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","forEach","callback","length","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"sources":["C:/Users/lauta/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"sourcesContent":["import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}